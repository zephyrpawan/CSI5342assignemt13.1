model RBAC

-- classes
-- ***************************************************************
class Role
attributes
  name : String
operations
  grantPermission(p : Permission)
  revokePermission(p : Permission)

  checkAccess(obj : Object, op : Operation) : Boolean =
    self.permission->exists(p | p.operation->includes(op)) and
    self.permission->exists(p | p.object->includes(obj)) and
    op.object->includes(obj) and
    self.l1.p1.object->includes(obj) and
    self.l1.p2.operation->includes(op)

  addAscendant(r : Role)
  deleteAscendant(r : Role)

  addDescendant(r : Role)
  deleteDescendant(r : Role)

  addSSDRole(r : Role)
  deleteSSDRole(r : Role)

  addDSDRole(r : Role)
  deleteDSDRole(r : Role)

  assignedUsers() : Set(User)
  authorizedUsers() : Set(User)

  assignUser(u : User, r : Role)

  ascendants() : Set(Role)
  descendants() : Set(Role)

  ssdRoles() : Set(Role)
  dsdRoles() : Set(Role)

  addPermission(p : Permission, r : Set(Role), obj : Set(Object), op : Set(Operation), rl : Set(Location), ol : Set(Location))
  deletePermission(p : Permission)

  addRoleAssignLocation(r : Role, l : Set(Location))
  deleteRoleAssignLocation(r : Role, l : Set(Location))
  addRoleActivateLoc(r : Role, l : Set(Location))
  deleteRoleActivateLoc (r : Role, l : Set(Location))
end

-- ***************************************************************
class User
attributes
  userID : String
  name: String
operations
  createSession() : Session
  deleteSession(s : Session)
  assignRole(r : Role)
  deassignRole(r : Role)
  assignedRoles() : Set(Role)
    begin
        result := self.role->asSet();
    end
  authorizedRoles() : Set(Role)
end

-- ***************************************************************
class Permission
operations
  checkAccess(obj : Object, op : Operation) : Boolean =
    self.object->includes(obj) and
    self.operation->includes(op) and
    op.object->includes(obj) and
    self.l2.object->includes(obj)
end

-- ***************************************************************
class Object
attributes
  name : String
end

-- ***************************************************************
class Operation
attributes
  name : String
end

-- ***************************************************************
class Session
attributes
  name : String
operations
  addActiveRole(r : Role)
  dropActiveRole(r : Role)
  checkAccess(obj : Object, op : Operation) : Boolean =
    self.role.permission->exists(p | p.operation->includes(op)) and
    self.role.permission->exists(p | p.object->includes(obj)) and
    op.object->includes(obj) and
    self.user.location->forAll(loc | self.role.l1->includes(loc))
  invokeOperation(obj : Object, op : Operation)
end
-- ***************************************************************
class Location
operations
  userLocation(u : User) : Location
  activateLocationByUser(u : User) : Set(Location)
  activateLocationByRole(r : Role) : Set(Location)

  --maps a set of roles to a set of locations from where the role can be activated
  assignLocation(r : Role)

  -- permRoleLoc gives a set of allowable locations for the role associated with a given permission
  permRoleLoc(p : Permission) : Set(Location)

  -- permRoleObj gives a set of allowable locations for the object associated with a given permission
  permObjLoc(p : Permission) : Set(Location)
end
-- ***************************************************************

-- associations
association UserAssignment between
  User[*] role user
  Role[*] role role
end

-- ***************************************************************
association PermAssignment between
  Permission[*] role permission
  Role[*] role role
end

-- ***************************************************************
association UserSessions between
  User[*] role user
  Session[*] role session
end

-- ***************************************************************
association SessionRoles between
  Session[*] role session
  Role[*] role role
end

-- ***************************************************************
association PermObjects between
  Permission[*] role permission
  Object[*] role object
end

-- ***************************************************************
association PermOperations between
  Permission[*] role permission
  Operation[*] role operation
end

-- ***************************************************************
association ExecuteOn between
  Operation[1..*] role operation
  Object[1..*] role object
end

-- ***************************************************************
association RoleHierarchy between
  Role[*] role senior
  Role[*] role junior
end

-- ***************************************************************
association SSD between
  Role[*] role rs1
  Role[*] role rs2
end

-- ***************************************************************
association DSD between
  Role[*] role rd1
  Role[*] role rd2
end

-- ***************************************************************
association UserLocation between
  User[*] role user
  Location[1] role location
end

-- ***************************************************************
association ActivateLocation between
  Role[*] role r1
  Location[1] role l1
end

-- ***************************************************************
association AssignLocation between
  Role[*] role r2
  Location[1] role l2
end

-- ***************************************************************
association PermRoleLoc between
  Location[*] role l1
  Permission[*] role p1
end

-- ***************************************************************
association PermObjLoc between
  Location[*] role l2
  Permission[*] role p2
end

-- ***************************************************************
association ObjLocation between
  Location[1] role location
  Object[*] role object
end

-- ***************************************************************

-- OCL constraints
constraints

-- creates a new session object and associates the user with the new session
context User :: createSession() : Session
  post: result.oclIsNew() = true and self.session->includes(result)

-- Permission can be granted if missing
context Role :: grantPermission(p : Permission)
  pre: self.permission->excludes(p)
  post: self.permission->includes(p)

-- Permission can be removed if present
context Role :: revokePermission(p : Permission)
  pre: self.permission->includes(p)
  post: self.permission->excludes(p)

-- SSD-Role constraint: Conflicting roles cannot be assigned to the same user
context Role
  inv SSDRole:
    rs1.user->excludesAll(rs2.user)

-- SSD-Permission constraint: Conflicting permissions cannot be assigned to the same role.
context Permission
  inv SSDPermission:
    Permission.allInstances->forAll(p1, p2 | p1 <> p2 implies p1.role->excludesAll(p2.role))

-- SSD constraint: A user cannot be assigned to two roles that are involved in an SSD relation
context User
  inv SSDUserConstraint:
    self.role->forAll(r1, r2 | r1.rs1->excludes(r2))

-- DSD constraint. A user cannot activate two roles in DSD relation within a session.
context User
  inv DSDUserConstraint:
    self.session.role->forAll(r1, r2 | r1.rd1->excludes(r2))

-- Hierarchical SSD constraint.
-- There cannot be roles in an SSD relation which have the same senior role.
context Role
 inv HierarchicalSSDConstraint:
   self.senior->forAll(j1, j2 | j1.junior->excludesAll(j2.senior))

-- This precondition is optional as the Permission.checkAccess will return false in this case
context Permission::checkAccess(obj : Object, op : Operation) : Boolean
  --  pre1: check whether op and obj are valid objects
  pre: op.oclIsKindOf(Operation)
  pre: obj.oclIsKindOf(Object)
  -- pre2: check whether obj is in acceptable location
  --pre: self.l2.object->includes(obj) -- permObjLoc

context Role::checkAccess(obj : Object, op : Operation) : Boolean
  --  pre1: check whether op and obj are valid objects
  pre: op.oclIsKindOf(Operation)
  pre: obj.oclIsKindOf(Object)
  -- pre2: check whether permission associated with obj and op is in acceptable location for role assignment
  --pre: self.l2.p1.object->includes(obj)
  --pre: self.l2.p2.operation->includes(op)

context Session::checkAccess(obj : Object, op : Operation) : Boolean
  --  pre1: check whether op and obj are valid objects
  pre: op.oclIsKindOf(Operation)
  pre: obj.oclIsKindOf(Object)

-- Each permission must be associated with 1 or more objects and operations
context Permission
  inv minimumOperationsAndObjects:
    self.operation->size() > 0 and self.object->size() > 0

-- Each object must be have at least a permission for 1 operation
context Object
  inv minPermissionOnObject:
    self.permission->size() > 0 and self.operation->size() > 0

-- Each operation must be associated with a permission to be executed on a object
context Operation
 inv minPermissionAndOperations:
   self.permission->size() > 0 and self.object->size() > 0

-- A role must have at least 1 permission and at least 1 user assigned
context Role
  inv minPermission:
    self.permission->size() > 0 and self.user->size() > 0

-- A session can have only 1 user tied to it
context Session
  inv sessionIsFor1SpecificUser:
    self.user->size() = 1

-- pawan
-- userLocation: all users must be associated with a location (pg. 3)
context User
  inv allUsersMustHaveLocation:
    User.allInstances->forAll(usr | usr.location->size() = 1)

-- objLocation: all objects are associated with locations and each location associated with an obj must be in an allowable loc (pg. 5)
context Object
  inv allObjectsAssociatedWithAllowableLocations:
    Object.allInstances->forAll(obj | obj.location->size() >= 1
    and obj.permission.l2->includes(obj.location))

-- addRoleAssignLocation: associates a new set of locations with a role. The operation takes as input a role r and a set of locations l
context Role :: addRoleAssignLocation(r : Role, l : Set(Location))
      --verifies whether r is a valid role by checking whether r is in the set Roles
  pre: Role.allInstances->includes(r)
      --whether l is a subset of Locations
  pre: Location.allInstances->includesAll(l)
      -- The post condition changes the object AssignLocation. The role r is now mapped to the set of original locations union l
  post: r.l2->includesAll(l2@pre->union(l))

-- deleteRoleAssignLocation: takes as input a role r and a set of locations l
context Role :: deleteRoleAssignLocation(r : Role, l : Set(Location))
     --verifies role r is a valid role by checking whether r is in the set Roles
  pre: Role.allInstances->includes(r)
     --checks whether l is a subset of the locations that are associated with the assignment of role r.
  pre: r.l2->includesAll(l)
     --removes l from the set of roles associated with r.
  post: r.l2->excludesAll(l)

-- addRoleActivateLoc: associates a new set of active locations for a role.
context Role :: addRoleActivateLoc(r : Role, l : Set(Location))
    --verifies whether r is a valid role by checking whether r is in the set Roles
  pre: Role.allInstances->includes(r)
    --verifies l is a subset of Locations
  pre: Location.allInstances->includesAll(l)
    -- The role r is now mapped to the set of original activate locations union l
  post: r.l1->includesAll(l1@pre->union(l))

-- deleteRoleActivateLoc: removes a of locations from a role
context Role :: deleteRoleActivateLoc (r : Role, l : Set(Location))
     --verifies role r is a valid role by checking whether r is in the set Roles
  pre: Role.allInstances->includes(r)
     --checks whether l is a subset of the active locations that are associated with the assignment of role r.
  pre: r.l1->includesAll(l)
     --removes l from the set of active roles associated with r.
  post: r.l1->excludesAll(l)

-- sarah
-- addPermission: adds a new permission to the set Permissions (pg.10)
context Role :: addPermission(p : Permission, r : Set(Role), obj : Set(Object), op : Set(Operation), rl : Set(Location), ol : Set(Location))
  -- pre1: checks that p is not an existing permission
  pre: self.permission->excludes(p)
  -- pre2: checks whether obj is a valid set of objects
  pre: obj->forAll(obj1 | obj1.oclIsKindOf(Object))
  -- pre3: checks whether op is a valid set of operations
  pre: op->forAll(op1 | op1.oclIsKindOf(Operation))
  -- pre4: checks whether rl is a valid set of role locations
  pre: rl->forAll(rl1 | rl1.oclIsKindOf(Location))
  -- pre5: checks whether ol is a valid set of object locations
  pre: ol->forAll(ol1 | ol1.oclIsKindOf(Location))
  -- post1: change set of Permissions to include p1
  post: self.permission->includes(p)
  -- post2: permObject, permOper, PermRoleLoc, and permObjLoc are updated to include the mappings of p to obj, op, rl, and ol
  post: rl->forAll(rl1 | self.l2->includes(rl1))
  post: self.l2.p1->includes(p) -- permRoleLoc
  post: self.l2.p2->includes(p) -- permObjLoc
  post: obj->forAll(obj1 | self.permission.object->includes(obj1)) -- permObject
  post: op->forAll(op1 | self.permission.operation->includes(op1)) -- permOper
  post: ol->forAll(ol1 | self.l2.object->includes(ol1)) -- objLocation

-- deletePermission: removes a permission p from set Permissions (pg. 10)
context Role :: deletePermission(p : Permission)
  -- pre1: checks that p is an existing permission by checking if it is in the set Permissions
  pre: self.permission->includes(p) -- permAssign
  -- post1: changes the objects permObject, permOper, permRoleLoc, permObjLoc by removing the entries associated with p in each of the objects
  post: p.l1->forAll(rl | self.permission.l1->excludes(rl)) -- assignLocation
  post: p.l2.object->forAll(ol1 | self.l2.object->excludes(ol1)) -- objLocation
  post: self.l2.p1->excludes(p) -- permRoleLoc
  post: self.l2.p2->excludes(p) -- permObjLoc
  post: p.object->forAll(obj1 | self.permission.object->excludes(obj1)) -- permObject
  post: p.operation->forAll(op1 | self.permission.operation->excludes(op1)) -- permOper
  -- post2: removes p from Permissions and changes permAssign by removing the entry associated with p
  post: self.permission->excludes(p)

-- assignUser: pg. 11
context Role :: assignUser(u : User, r : Role)
  -- pre1: checks whether u is valid
  pre: u.oclIsKindOf(User)
  -- pre2: checks whether r is valid
  pre: r.oclIsKindOf(Role)
  -- pre3: ensures that r is not in the set of roles assigned to u
  pre: u.role->excludes(r)
  -- pre4: checks whether the location of the user is contained in the locations where r can be assigned
  pre: self.l2->includes(u.location)
  -- post: userAssign is changed so that u maps to the set consisting of the roles previously assigned to u and r
  post: self.user->includes(u)
  post: u.role->includes(r)

-- addActiveRole: activate a role for a user in a session (pg. 13)
context Session :: addActiveRole(r : Role)
  -- pre1: check whether r is an existing role
  pre: r.oclIsKindOf(Role)
  -- pre2: check whether r is a role associated with user associated with this session
  pre: self.user.role->includes(r)
  -- pre3: check whether the location of the user in this session is within the activation location of r
  pre: self.user.location->forAll(loc | r.l1->includes(loc))
  -- post1: sessionRole is updated so that session is now associated with r
  post: self.role->includes(r)

-- activateLocationByUser
-- activateLocationByRole
